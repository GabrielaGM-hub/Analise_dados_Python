# -*- coding: utf-8 -*-
"""Introdução a data science

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18yUuba-SV6GtTNZGqSMLIIi1XrdDSWsZ

# **Dados sobre filmes - MOVIELENS DO GROUPLENS**

**USANDO A BIBLIOTECA "PANDAS"**
"""

# carregar os arquivos "movies", "ratings" e "tmdb_500_movies"
# sites para baixar dados: kaggle / google dataset research

# Importando as bibliotecas usadas
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Lendo o arquido de dados
# Pandas é a biblioteca para analisar os dados
import pandas as pd

# carregar o arquivo csv antes de rodar os comandos abaixo
notas = pd.read_csv("ratings.csv")
notas.head()  # mostra os 5 primeiros elementos -  a cabeça

# Qual é o formato dessa tabela (do dataframe - linhas, colunas)
notas.shape

# Renomeando os nomes das colunas
notas.columns = ["usuarioId", "filmeId", "nota", "momento"]
notas.head()

# Quais são todos os valores da coluna nota?
notas["nota"]

# Quais são os valores (únicos) na coluna da nota?
notas["nota"]. unique()  # verá que não foi dada a nota 0 nesse conjunto de dados

# Quantas vezes apareceu a nota 4 ou a nota 5?
notas["nota"].value_counts()

# Qual é a média de todas as notas?
notas["nota"].mean()

# Outra forma de ler a coluna nota + plotando a série notas
notas.nota.head()

# O histograma também é conhecido como "distribuição de frequências", e é representado em um gráfico de colunas ou de barras a partir de um conjunto de dados previamente tabulado e dividido em classes (uniformes ou não uniformes).

# Plotando as notas - gráfico com todas as notas
notas.nota.plot(kind="hist")

# Qual é o valor que divide metade para baixo e metade para cima? Não é a média, quero saber a MEDIANA
notas["nota"].median()

# Se eu quiser ver a MÉDIA e a MEDIANA com a saída com dois resultados juntos
print("Media", notas["nota"].mean())
print("Mediana", notas["nota"].median())

# Tirando todas as características de uma vez só (média, mediana, max, min, etc)
notas.nota.describe()

"""## **ANÁLISE EXPLORATÓRIA DE DADOS E GRÁFICOS**

**USANDO A BIBLIOTECA "seaborn"**
"""

# Importando a biblioteca
import seaborn as sns

# oxplot, também conhecido como "diagrama de caixa", é um método alternativo para o histograma. Uma de suas particularidades é mostrar a faixa em que está concentrada a mediana dos valores.

# Fazendo o boxplot
sns.boxplot(notas.nota)

# a medida está no meio, 3,5
# os riscos são os restantes das notas, 25%
# metade das pessoas estão dando nota entre 3 e 4
# 25% das notas estão entre 4 e 5
# 25% das notas estão entre 1,5 e 3
# as notas 0,5 e 1 são as bolinhas

# Faça o upload do arquivo csv movies

# Quais são os filmes que estão no dataframe?
filmes = pd.read_csv("movies.csv")
filmes.head()

# Renomeando os nomes das colunas
filmes.columns = ["filmeId", "titulo", "generos"]
filmes.head()

"""# **Analisando as notas de filmes específicos**"""

# Vendo as notas do Toy Story - Quero fazer a pergunta 9query) quando filmeId=1 (Toy Story)
# só as avaliações do filme Toy Story
notas.query("filmeId==1")

# Mas só estou interessada na coluna nota
notas.query("filmeId==1").nota

# Quero a média das notas do Toy Story - filmeId==1
notas.query("filmeId==1").nota.mean()
# é uma média acima de quando consideramos todos os filmes

# Quero a média das notas do Jumangi - filmeId==2
notas.query("filmeId==2").nota.mean()

# GROUPBY - agrupar

# Peganto todas as notas e agrupar pelo filme
notas.groupby("filmeId")

# Fazendo a média
#notas.groupby("filmeId").mean()
medias_por_filme = notas.groupby("filmeId").nota.mean()
# medias_por_filme = notas.groupby("filmeId").mean()["nota"]  # outra forma
medias_por_filme.head()

medias_por_filme.plot(kind="hist")

plt.figure(figsize=(5,10))  # funções do matplot para formatar a imagem
sns.boxplot(medias_por_filme)

# Fazendo o boxplot vertical
sns.boxplot(y=medias_por_filme)

# Fazendo o boxplot horizontal
sns.boxplot(x=medias_por_filme)

medias_por_filme.describe()

# histograma no pacote sns
sns.distplot(medias_por_filme)
#sns.distplot(medias_por_filme, bins=20) # escolhe o numero de "caxinhas/colunas" para plotar

"""# Importanto a biblioteca matplotlib"""

# pandas e seaborn usam o matplotlib para fazer suas plotagens, vc pode usar a biblioteca direta
import matplotlib.pyplot as plt

plt.hist(medias_por_filme)
plt.title("Histograma das médias dos filmes")
plt.xlabel("Média")
plt.ylabel("Frequência")

"""# **3. VARIÁVEIS**

"""

# Importando outra base de dados de filmes: tmdb 5000
# fazer o upload do arquivo "tmdb_5000_movies.csv"

tmbd = pd.read_csv("tmdb_5000_movies.csv")
tmbd.head()

"""As **variáveis categóricas** são aquelas que não possuem valores quantitativos, mas, ao contrário, são definidas por várias categorias, ou seja, representam uma classificação dos indivíduos. Podem ser nominais ou ordinais.

Quando estamos trabalhando com categorias ordinais, existe uma ordenação entre as categorias.
Por exemplo: escolaridade (primeiro, segundo e terceiro graus), estágios de uma doença (inicial, intermediário, terminal), mês de observação (janeiro, fevereiro, ..., dezembro), etc.
"""

# Quais são as linguas - É UMA VARIÁVEL CATEGÓRICA NOMINAL - Não existe uma ordem ou ranking
tmbd.original_language.unique()

# CATEGORICA ORDINAL: primeiro grau < segundo grau < terceiro grau
# QUANTITATIVA CONTÍNUO: orçamento
# QUANTITATIVA (intervalar): quantidade de votos (1, 2, 3, mas não tem 2,5 votos)
# QUANTITATIVA (intervalar): notas do movielens (0,5, 1, 1,5, 2, 2,5, 3 de 0,5 em 0,5)

"""# **4. DATA VISUALIZATION**"""

# Contando quantas vezes aparece cada idioma
contagem_de_lingua = tmbd["original_language"].value_counts().to_frame().reset_index()
contagem_de_lingua.columns = ["original_language", "total"]
contagem_de_lingua.head()

# Visualizando essas categorias, para comparação (categorical plot)
sns.barplot(x= "original_language", y = "total", data = contagem_de_lingua)

# Fazendo o plot de uma vez só, direto
sns.catplot(x= "original_language", kind="count", data = tmbd)

# Gráfico de pizza

# não tem no pacote sns
plt.pie(contagem_de_lingua["total"], labels = contagem_de_lingua["original_language"])

# Ao plotar os dados de lingua assim, não temos plot bons. Eles nos mostram que EN é a principal linguagem.
# O que pode ser feito, para melhorar a visualização do gráfico, é comparar o inglês com as outras línguas.

total_por_lingua = tmbd["original_language"].value_counts()
total_geral = total_por_lingua.sum()
total_de_ingles = total_por_lingua.loc["en"]
total_do_resto = total_geral - total_de_ingles
print(total_de_ingles, total_do_resto)

# ingles = 4505
# outras linguas = 298

# Criando um dataframe para a plotagem
dados = {
    "lingua": ["ingles", "outros"],
    "total": [total_de_ingles, total_do_resto]
}
dados = pd.DataFrame(dados)
dados.head()

sns.barplot(x = "lingua", y= "total", data = dados)

# Gráfico de pizza

# não tem no pacote sns
plt.pie(dados["total"], labels = dados["lingua"])

# Entendo as outras línguas - "outros"
# pegando dataframe completo e buscando apenas as outras línguas, tirando o inglês
#tmbd.query("original_language == 'en'") # só ve os filmes com lingua original em inglês
total_por_lingua_de_outros_filmes = tmbd.query("original_language != 'en'").original_language.value_counts() # só ve os filmes com lingua original diferente de inglês
total_por_lingua_de_outros_filmes.head()

filmes_sem_lingua_original_em_ingles = tmbd.query("original_language != 'en'").original_language.value_counts()


# Fazendo o plot de uma vez só, direto
sns.catplot(x="original_language", y="count", data=filmes_sem_lingua_original_em_ingles, kind="bar")

"""#Refinando as visualizações"""

# ver a biblioteca do catplot seaborn
sns.catplot(x="original_language", y="count", data=filmes_sem_lingua_original_em_ingles_df, kind="bar",
            aspect = 2,
            order = total_por_lingua_de_outros_filmes.index,
            palette = "GnBu_d")

# Outro exemplo de plot usando o seaborn
#o s dados já estão no pacote

sns.set(style="ticks")

# Load the example dataset for Anscombe's quartet
df = sns.load_dataset("anscombe")

# Show the results of a linear regression within each dataset
sns.lmplot(x="x", y="y", col="dataset", hue="dataset", data=df,
           col_wrap=2, ci=None, palette="muted", height=4,
           scatter_kws={"s": 50, "alpha": 1})

"""```
# Isto está formatado como código
```

# **6. Dados e estatística**

Revisando o papel da média, mediana, medidas de tendência central, dispersão, desvio padrão, boxplot, histograma
"""

filmes.head()

filmes.head(2)

notas.head()

# Qual é a nota média do Toy Story?
# Qual é a nota média do Jumanji?
notas_do_toy_story = notas.query("filmeId==1")
notas_do_jumanji = notas.query("filmeId==2")
print(len(notas_do_toy_story), len(notas_do_jumanji))

# tem 215 notas do toy story e 110 notas do jumanji

print("Nota média do Toy Story", notas_do_toy_story.nota.mean())
print("Nota média do Jumanji", notas_do_jumanji.nota.mean())

# mediana separa do meio, 50% para cima e 50% para baixo
print("Nota média do Toy Story", notas_do_toy_story.nota.median())
print("Nota média do Jumanji", notas_do_jumanji.nota.median())

# criando notas aleatórias

filme1 = np.append(np.array([2.5] * 10), np.array([3.5] * 10))
filme2 = np.append(np.array([5] * 10), np.array([1] * 10))

# média
print(filme1.mean())
print(filme2.mean())

# mediana
print(np.median(filme1))
print(np.median(filme2))

# desvio padrão
print(np.std(filme1))
print(np.std(filme2))

sns.distplot(filme1)
sns.distplot(filme2)

plt.hist(filme1)
plt.hist(filme2)

sns.boxplot([filme1, filme2])

# a média e a mediana tentar resumir toda a distribuição dos dados em um único número
# vendo a distribuição do Toy Strory e Jumanji
plt.boxplot([notas_do_toy_story.nota, notas_do_jumanji.nota])

sns.boxplot(x = "filmeId", y = "nota", data = notas.query("filmeId in [1,2,3,4,5]"))

print(notas_do_toy_story.nota.std())
print(notas_do_jumanji.nota.std())