# -*- coding: utf-8 -*-
"""Análise da dados dos profissionais da ciência de dados

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1joDJbSJZNcDAG1rRK-pwLA4_DzdeZeZQ

# Entendendo os dados sobre os salários daqueles que trabalham na área de dados:

Algumas observações:

*   ( ) parênteses = usa para chamar de função, operações matemáticas
*   { } chaves = criação de uma lista/dicionário

# **AULA 1 - Explorando dados com a biblioteca pandas**

> Adicionar aspas
"""

# Importando as bibliotecas
import pandas as pd   # análise de dados

# Importando a base de dados de um repositório do Github
# daremos o nome de df (dataframe), mas pode ser o nome que desejar

# lendo os dados com a biblioteca pandas
df = pd.read_csv("https://raw.githubusercontent.com/guilhermeonrails/data-jobs/refs/heads/main/salaries.csv")

# dados vem do Kaggle

# Primeira visualização para entender o que tem nessa base de dados
df.head()  # mostra apenas as 5 primeiras linhas
df.head(10)  # mostra as 10 primeiras linhas

# df trata dos salários que pessoas que trabalham na área de dados

# Analisando as informações do df
df.info()

# float: numérico com casas decimais
# object:
# int64: numérico sem casas decimais
# não tem dados nulos

# Entendo melhor a base de dados - ESTATÍSTICA DESCRITIVA
# usando só os dados numéricos (float ou int)
df.describe()


# count: contagem, quantos registros tem para a coluna
# mean: média
# std: desvio padrão
# min: mínimo que recebeu naquele ano
# max: máximo que recebeu naquele ano

# Qual o tamanho da base
df.shape

# são 133.349 linhas e 11 colunas

# Deixando a quantidade de linhas e colunas com uma visualização melhor
# criando as variáveis "linhas", que guarda a quantidade de linhas, e "colunas" que guarda a quantidade de colunas
linhas, colunas = df.shape[0], df.shape[1]

# a quantidade de linhas começa no zero (0), posição 1 que pega a quantidade de colunas

# para ver as linhas e colunas
print("Número de colunas:", colunas)
print("Numero de linhas:", linhas)       # em aspas são o texto que quer ser impresso, nome para aparecer no relatório

# Quais os nomes das colunas?
df.columns

# elas estão em inglês

# Traduzindo os nomes das colunas para português
renomear_colunas = {
    'work_year': 'ano',
    'experience_level': 'nivel_experiencia',
    'employment_type': 'contrato',
    'job_title': 'cargo',
    'salary': 'salario',
    'salary_currency': 'moeda_salario',
    'salary_in_usd': 'salario_usd',
    'employee_residence': 'residencia_empregado',
    'remote_ratio': 'remoto',
    'company_location': 'localizacao_empresa',
    'company_size': 'tamanho_empresa'
}

df.rename(columns = renomear_colunas, inplace = True)
df.columns

"""## **Analisando as variáveis (colunas)**

"""

# Qual é a frequencia da variável "nível de experiência", em cada categoria
df["nivel_experiencia"].value_counts()

# SE: senior, MI: intermédiario/medium, EN: junior, EX: executivo/liderança

"""A maior parte dos indivíduos tem um nível de experiência "senior"."""

# Qual é a frequencia da variável "contrato", em cada categoria
df["contrato"].value_counts()

# FT: fulltime; CT: contrato temporário; PT: part time, FL: freelance

"""A maior parte dos indivíduos tem um contrato de trabalho em tempo integral (fulltime)."""

# Qual é a frequencia da variável "remoto"
df["remoto"].value_counts()

"""A maior parte dos indivíduos trabalha presencialmente.(maioria das vagas são presenciais)"""

# Qual é a frequencia da variável "tamanho da empresa"
df["tamanho_empresa"].value_counts()

# M: médio, L: grande, S: pequeno

"""A maior parte das empresas é de médio porte.

### Além de renomear as colunas, fica mais intuitivo renomear as categorias para que quando for necessário fazer relatórios, gráficos e dashboards a visualização seja melhor.
"""

# Traduzindo os nomes das categorias da variável "tempo de experiência"
substituir_nivel_experiencia = {
    "SE": 'Senior',
    "MI": 'Pleno',
    "EN": 'Junior',
    "EX": 'Executivo'
}

df["nivel_experiencia"] = df["nivel_experiencia"].replace(substituir_nivel_experiencia)
df["nivel_experiencia"].value_counts()

# Traduzindo os nomes das categorias da variável "contrato"
substituir_contrato = {
    "FT": 'Tempo integral',
    "PT": 'Tempo parcial',
    "FL": 'Freelance',
    "CT": 'Contrato temporário'
}

df["contrato"] = df["contrato"].replace(substituir_contrato)
df["contrato"].value_counts()

# Traduzindo os nomes das categorias da variável "tamanho da empresa"
substituir_tamanho_empresa = {
    "S": 'Pequena',
    "L": 'Grande',
    "M": 'Média',
}

df["tamanho_empresa"] = df["tamanho_empresa"].replace(substituir_tamanho_empresa)
df["tamanho_empresa"].value_counts()

# Traduzindo os nomes das categorias da variável "remoto"
substituir_remoto = {       # como as categorias estão em número, não usar as aspas
    0: 'Presencial',
    50: 'Híbrido',
    100: 'Remoto'
}

df["remoto"] = df["remoto"].replace(substituir_remoto)
df["remoto"].value_counts()

# Verificando as mudanças
df.head()

"""Usando o "describe" para ver variáveis categóricas  e contínuas(antes usamos só para as contínuas)"""

# ESTATÍSTICA DESCRITIVA
df.describe(include = "object")

# count = contagem de números na colunas
# unique = categorias (por exemplo, moeda salário tem 26 moedas diferentes; remoto tem 3 categorias - presencial, remoto e híbrido)
# top: qual informação é mais frequente (nível de experiência mais comum: senior)
# freq: fequencia - quantas vezes esse valor "top" está se repetindo (senior aparece 77.241 vezes)

df.describe()

"""# **AULA 2 - Limpando e preparando os dados**"""

# verificando se há informações nulas ou ausentes, não prenchidas de algo
df.isnull()

"""Onde não há dado nulo, é indicado como "False".
Se tiver dado nulo, indicará com "True".

Pela tabela acima (5 primeiras e 5 últimas linhas) não sabe se tem infos nulas em toda a base. É mais interessante fazer a soma para verificar os nulos.
"""

# indentificando onde estão os valores faltantes
df.isnull().sum()

"""Veja que aparece todas as variáveis que compõem o dataframe.
Para todas aparece o valor 0 (zero), indicando que a soma do que é nulo, é igual a zero, ou seja, não há valores faltantes.
Exceto para a variável ano, que o valor 10 indica que possui 10 registros que não tem a variável ano preenchido.
"""

# Mas quais são os anos dentro dessa base de dados?
# usamos o "unique" para verificar os valores únicos

df["ano"].unique()

# nan = valor nulo - NOT A  NUMBER

# Quais são as linhas que possuem esse "NAN" para a variável ano?
df[df.isnull().any(axis = 1)]

"""O que fazer com os dados nulos?????

Existem 3 possibilidades:


1.   Inserir informações
2.   Excluir os dados (observações) que não possuem as informações
3.   Fazer a importação usando alguma regra

**Pensando na primeira opção: INSERIR INFORMAÇÕES**

Nesse caso, poderíamos inserir a **média** ou a **mediana** para não descalibrar a base de dados.
"""

# importar o numpy que é uma biblioteca para manipulação de dados
import numpy as np


# Como não é viável fazer a média/mediana dos anos, vamos criar um dataframe apenas para ilustrar a primeira possibilidade
# vamos pensar em um caso que um df tenha valores de salários diferentes

# criando um df de teste
df_salarios = pd.DataFrame({
    "nome": ["Ana", "Bruno", "Carlos", "Daniele", "Val"],  # usa aspas pq não é uma variável numérica
    "salario": [4000, np.nan, 5000, np.nan, 100000]  # np.nan - usado para indicar o valor nulo
})


# Preenchendo os dados faltantes com a MÉDIA, calculando a média
df_salarios["salario_media"] = df_salarios["salario"].fillna(df_salarios["salario"].mean().round(2))
df_salarios

# Preenchendo os dados faltantes com a MEDIANA, calculando a média
df_salarios["salario_mediana"] = df_salarios["salario"].fillna(df_salarios["salario"].median())
df_salarios

"""**Pensando na terceira opção: INSERIR INFORMAÇÕES usando uma regra**

Pensando em um exemplo de temperatura, que temos dados da temperatura máxima por dia.
Porém, em alguns dias temos "nan". O que poderia ser feito? Uma possibilidade seria repetir a temperatura máxima do dia anterior.
"""

df_temperaturas = pd.DataFrame({
    "Dia": ["Segunda", "Terça", "Quarta", "Quinta", "Sexta"],
    "Temperatura": [30, np.nan, np.nan, 28, 27]
})

# criando uma nova coluna
df_temperaturas["preenchico_ffill"] = df_temperaturas["Temperatura"].ffill()
df_temperaturas

# ffill = forward fill - completar com o anterior

# E SE A SEGUNDA NÃO TIVESSE VALOR? podemos pensar em outra estratéga usando os dados do dia seguinte

# criando uma nova coluna
df_temperaturas["preenchico_bfill"] = df_temperaturas["Temperatura"].bfill()
df_temperaturas

# bfill = backward fill - completar com o seguinte

"""Pensando em outro exemplo...

Suponha um dataframe composto por algumas pessoas, mas algumas delas não disponibilizaram o local de moradia.
"""

df_cidades = pd.DataFrame({
    "nome": ["Ana", "Bruno", "Carlos", "Daniele", "Val"],  # usa aspas pq não é uma variável numérica
    "cidade": ["São Paulo", np.nan, "Curitiba", np.nan, "Belém"]
  })

df_cidades["cidade_preenchida"] = df_cidades["cidade"].fillna("Não informado")
df_cidades

"""Considerando o exemplo das cidades, uma opção é deixar o "Não informado". Mas, caso a base de dados for muito grande, retirar algumas informações dela não traria prejuízo. Então vamos pensar na possibilidade de retirar as observações que possuem a cidade como "Não informado".

**Pensando na segunda opção: EXCLUIR OS DADOS**
"""

# uma boa prática não é excluir do dataframe original. Vai que dá ruim né?

# vamos criar uma nova variável para armanezar
df_limpo = df.dropna()

# verificando se as informações com os nulos foram excluídas
df_limpo.isnull().sum()
# todos os valores estão zerados, não temos mais dados faltantes

df_limpo.head()
# veja que a coluna ano tem casas decimais, isso não faz muito sentido

df_limpo.info()
# a variável ano é do tipo float64, que é o número com casas decimais

# vamos converter o tipo da variável "ano" de float64 pq não tem casas deciais para int64
df_limpo = df_limpo.assign(ano = df_limpo["ano"].astype("int64"))
df_limpo.info()

df_limpo.head()

"""# **AULA 3 - Criando gráficos**"""

# lembrando dos nossos dados
df_limpo.head()

# a biblioteca pandas pode ser usada pra plotar gráficos, embora tenha limitações na questão da customização

# contagem das categorias da variável "experiência"
df_limpo['nivel_experiencia'].value_counts().plot(kind = 'bar', title = 'Distribuição do nível de experiência')

"""Eixo x: nível de experiência;
Eixo y: contagem de cada categoria

Vamos pensar em uma empresa com essas características.
Talvez, no futuro ela tenha problema pois tem mais que o dobro de "senior" do que "pleno", e com poucos "juniores".
Estou conseguindo treinar essas pessoas?

# Para customizar os gráficos temos duas grandes bibliotecas para usar:

1.   Matplotlib
2.   Seaborn
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Gráfico de barras
sns.barplot(data = df_limpo, x = "nivel_experiencia", y = "salario_usd")

# Customizando o gráfico de barras acima

# tamanho da figura
plt.figure(figsize = (8, 5))    # largura e altura

# gráfico de barras
sns.barplot(data = df_limpo, x = "nivel_experiencia", y = "salario_usd")

# inserindo o título
plt.title("Salário médio por nível de experiência (U$D)")

# inserindo o nome do eixo x
plt.xlabel("Nível de experiência")

# inserindo o nome do eixo y
plt.ylabel("Salário médio")

plt.show()    # mostra apenas o gráfico, sem textos em cima

# ordenando as barras de forma decrescente
df_limpo.groupby("nivel_experiencia")["salario_usd"].mean().sort_values(ascending = False)

# armazenando dentro de uma variável para passar como parâmetro para o seaborn fazer a ordenação

# Ordem descrescente
ordem = df_limpo.groupby("nivel_experiencia")["salario_usd"].mean().sort_values(ascending = False).index
ordem

# Customizando o gráfico de barras em ORDEM DESCRESCENTE

# tamanho da figura
plt.figure(figsize = (8, 5))    # largura e altura

# gráfico de barras
sns.barplot(data = df_limpo, x = "nivel_experiencia", y = "salario_usd", order = ordem)

# inserindo o título
plt.title("Salário médio por nível de experiência (U$D)")

# inserindo o nome do eixo x
plt.xlabel("Nível de experiência")

# inserindo o nome do eixo y
plt.ylabel("Salário médio")

plt.show()    # mostra apenas o gráfico, sem textos em cima

# E se quiser em ordem crescente?
ordem2 = df_limpo.groupby("nivel_experiencia")["salario_usd"].mean().sort_values(ascending = True).index
ordem2

# Customizando o gráfico de barras em ORDEM CRESCENTE

# tamanho da figura
plt.figure(figsize = (8, 5))    # largura e altura

# gráfico de barras
sns.barplot(data = df_limpo, x = "nivel_experiencia", y = "salario_usd", order = ordem2)

# inserindo o título
plt.title("Salário médio por nível de experiência (U$D)")

# inserindo o nome do eixo x
plt.xlabel("Nível de experiência")

# inserindo o nome do eixo y
plt.ylabel("Salário médio")

plt.show()    # mostra apenas o gráfico, sem textos em cima

# Como está a distribuição salarial? Será que está mais concentrado ou distribuido?

# tamanho da figura
plt.figure(figsize = (8, 4))    # largura e altura

# histrograma
sns.histplot(df_limpo["salario_usd"], bins = 50, kde = True)  # bins intervalos entre as barras do histograma / quantidade de barras
                                                              # kde - linha azul

# inserindo o título
plt.title("Distribuição dos salários anuais (U$D)")

# inserindo o nome do eixo x
plt.xlabel("Salário (U$D)")

# inserindo o nome do eixo y
plt.ylabel("Frequência")

plt.show()    # mostra apenas o gráfico, sem textos em cima

"""A distribuição está mais voltada a esquerda (não é normal). (calda longa)
A maioria dos salários está mais concentradanos nos valores mais baixos.
Maior parte dos salários está entre 150.000, poucas pessoas entre 700.000 e 800.000.
"""

# Como está a distribuição salarial? OLHANDO PELO BOXPLOT

# tamanho da figura
plt.figure(figsize = (8, 4))    # largura e altura

# boxplot
sns.boxplot(x = df_limpo["salario_usd"])

# inserindo o título
plt.title("Distribuição salarial por nível de experiência")

# inserindo o nome do eixo x
plt.xlabel("Salário (U$D)")

# inserindo o nome do eixo y
plt.ylabel("Frequência")


plt.show()    # mostra apenas o gráfico, sem textos em cima

"""Mostra a distribuição do salário por meio de uma caixa, evidenciando de um ponto a outro, o valor mínimo ao valor máximo.
A linha no meio da caixa é a mediana, o quartil de 25% e o quartil de 75%.
Acima da extremidade direita vemos diversos pontos que representam os outliers. Ou seja, são dados discrepantes dos que vemos da caixa, complementando o que vimos no histograma.

Tendo o cenário de uma empresa, qual salário deveria ter para atrair os melhores talentos pra sua empresa? Abaixo de 150.000 provavelmente está da mediana para baixo, talvez não seja interessante. Mas... para atrair os melhores poderá fazer uma estratégia que atraia esse talento, mas não saindo muito do padrão.
"""

# criando uma variável para identificar a ordem
ordem_experiencia = ["Junior", "Pleno", "Senior", "Executivo"]

# tamanho da figura
plt.figure(figsize = (8, 4))    # largura e altura

# boxplot
sns.boxplot(x = "nivel_experiencia", y = "salario_usd", data = df_limpo, order = ordem_experiencia)

# inserindo o título
plt.title("Distribuição salarial por nível de experiência")

# inserindo o nome do eixo x
plt.xlabel("Nível de experiência")

# inserindo o nome do eixo y
plt.ylabel("Salário (U$D)")


plt.show()    # mostra apenas o gráfico, sem textos em cima

"""Note como as medidas se diferem quando considerando o nível de experiência/senioridade.
Existem alguns outliers seniors que ganham mais que executivos.
"""

# MUDANDO AS CORES

# criando uma variável para identificar a ordem
ordem_experiencia = ["Junior", "Pleno", "Senior", "Executivo"]

# tamanho da figura
plt.figure(figsize = (8, 4))    # largura e altura

# boxplot e colocando uma cor para cada caixa
sns.boxplot(x = "nivel_experiencia", y = "salario_usd", data = df_limpo, order = ordem_experiencia, palette = "Set2", hue = "nivel_experiencia")

# inserindo o título
plt.title("Distribuição salarial por nível de experiência")

# inserindo o nome do eixo x
plt.xlabel("Nível de experiência")

# inserindo o nome do eixo y
plt.ylabel("Salário (U$D)")


plt.show()    # mostra apenas o gráfico, sem textos em cima

"""# **Partindo para os gráficos interativos ...**

Para isso usamos a biblioteca "plotly".
"""

import plotly.express as px

# Gráfico de barras por média salarial por nível de experiência

experiencia_media_salario = df_limpo.groupby("nivel_experiencia")["salario_usd"].mean().sort_values(ascending = False).reset_index()

fig = px.bar(experiencia_media_salario,
             x = "nivel_experiencia",
             y = "salario_usd",
             title = "Média salarial por nível de experiência",
             labels = {"nivel_experiencia": "Nível de experiência", "salario_usd": "Média salarial U$D"},
             color = "nivel_experiencia")
fig.show()

# Gráfico de PIZZA usando a variável de trabalho remoto

remoto_contagem = df_limpo["remoto"].value_counts().reset_index()

# Defifindo as colunas
remoto_contagem.columns = ["tipo_trabalho", "quantidade"]

fig = px.pie(remoto_contagem,
            names = "tipo_trabalho",
            values = "quantidade",
            title = "Proporção dos tipos de trabalho")
fig.show()

# TRANSFORMANDO O GRÁFICO DE PIZZA EM ROSCA

remoto_contagem = df_limpo["remoto"].value_counts().reset_index()

# Defifindo as colunas
remoto_contagem.columns = ["tipo_trabalho", "quantidade"]

fig = px.pie(remoto_contagem,
            names = "tipo_trabalho",
            values = "quantidade",
            title = "Proporção dos tipos de trabalho",
            hole = 0.5)
fig.update_traces(textinfo = "percent+label")

fig.show()

# Filtrando o DataFrame para incluir apenas "Data Scientist"
df_ds = df_limpo[df_limpo["cargo"] == "Data Scientist"]

# Calculando o salário médio por país para Cientistas de Dados
salario_medio_pais_ds = df_ds.groupby("localizacao_empresa")["salario_usd"].mean().reset_index()

# Ordenando os países pelo salário médio de forma decrescente
salario_medio_pais_ds = salario_medio_pais_ds.sort_values(by = "salario_usd", ascending = False)

# Criando o gráfico de barras interativo com Plotly Express
fig = px.bar(salario_medio_pais_ds,
             x = "localizacao_empresa",
             y = "salario_usd",
             title = "Salário médio para Cientistas de Dados por País (U$D)",
             labels = {"localizacao_empresa": "País", "salario_usd": "Salário médio (U$D)"})

fig.show()